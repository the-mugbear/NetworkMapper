"""
Vulnerability Management Service

Handles vulnerability data from multiple security tools with proper severity mapping
and source attribution for conflict resolution.
"""

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from sqlalchemy.orm import Session

from app.parsers.nessus_parser import NessusHost, NessusVulnerability
from app.db.models import Host, Port, Scan
from app.db.models_vulnerability import (
    Vulnerability,
    HostAttribute,
    PortAttribute,
    VulnerabilitySource,
    VulnerabilitySeverity
)

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Service for managing vulnerability data from multiple sources"""

    def __init__(self, db: Session):
        self.db = db

    def process_nessus_vulnerabilities(
        self,
        host: Host,
        nessus_host: NessusHost,
        scan: Scan
    ) -> Dict[str, int]:
        """
        Process Nessus vulnerabilities and store in new vulnerability schema

        Returns statistics about vulnerabilities processed
        """
        stats = {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}

        try:
            # Process host attributes with source attribution
            self._process_host_attributes(host, nessus_host, scan)

            # Process vulnerabilities
            for nessus_vuln in nessus_host.vulnerabilities:
                vuln = self._create_vulnerability_from_nessus(nessus_vuln, host, scan)
                if vuln:
                    stats["total"] += 1
                    if vuln.severity:
                        stats[vuln.severity.value] += 1

            return stats

        except Exception as e:
            logger.error(f"Error processing Nessus vulnerabilities for {host.ip_address}: {str(e)}")
            raise

    def _process_host_attributes(self, host: Host, nessus_host: NessusHost, scan: Scan):
        """Store host attributes with source attribution"""

        # Hostname attribution
        if nessus_host.hostname:
            self._create_host_attribute(
                host, "hostname", nessus_host.hostname,
                source="nessus", scan=scan, confidence=0.8
            )

        if nessus_host.netbios_name:
            self._create_host_attribute(
                host, "netbios_name", nessus_host.netbios_name,
                source="nessus", scan=scan, confidence=0.7
            )

        # OS attribution
        if nessus_host.operating_system:
            self._create_host_attribute(
                host, "os_name", nessus_host.operating_system,
                source="nessus", scan=scan, confidence=0.6
            )

    def _create_host_attribute(
        self,
        host: Host,
        attr_type: str,
        value: str,
        source: str,
        scan: Scan,
        confidence: float = 1.0
    ):
        """Create or update host attribute with source attribution"""

        # Check if this exact attribute already exists from this source
        existing = self.db.query(HostAttribute).filter(
            HostAttribute.host_id == host.id,
            HostAttribute.attribute_type == attr_type,
            HostAttribute.value == value,
            HostAttribute.source == source
        ).first()

        if existing:
            existing.last_seen = datetime.utcnow()
            existing.confidence = max(existing.confidence, confidence)
        else:
            attribute = HostAttribute(
                host_id=host.id,
                attribute_type=attr_type,
                value=value,
                confidence=confidence,
                source=source,
                scan_id=scan.id
            )
            self.db.add(attribute)

    def _create_vulnerability_from_nessus(
        self,
        nessus_vuln: NessusVulnerability,
        host: Host,
        scan: Scan
    ) -> Optional[Vulnerability]:
        """Convert Nessus vulnerability to standardized vulnerability record"""

        try:
            # Map Nessus severity to standard enum
            severity = self._map_nessus_severity(nessus_vuln.severity)

            # Find or create the port if this is a port-specific vulnerability
            port = None
            if nessus_vuln.port and nessus_vuln.port != 0:
                port = self._get_or_create_port(host, nessus_vuln.port, scan)

            # Check if this vulnerability already exists
            existing_vuln = self._find_existing_vulnerability(
                host, port, nessus_vuln.plugin_id, VulnerabilitySource.NESSUS
            )

            if existing_vuln:
                # Update existing vulnerability
                existing_vuln.last_seen = datetime.utcnow()
                existing_vuln.scan_id = scan.id  # Update to latest scan
                return existing_vuln

            # Create new vulnerability record
            vulnerability = Vulnerability(
                plugin_id=str(nessus_vuln.plugin_id),
                title=nessus_vuln.plugin_name,
                description=nessus_vuln.description or nessus_vuln.synopsis,
                severity=severity,
                source=VulnerabilitySource.NESSUS,
                source_plugin_name=nessus_vuln.plugin_name,
                host_id=host.id,
                port_id=port.id if port else None,
                scan_id=scan.id,
                solution=nessus_vuln.solution,
                references=self._format_references(nessus_vuln)
            )

            # Add CVE information if available
            if nessus_vuln.cve_list and len(nessus_vuln.cve_list) > 0:
                vulnerability.cve_id = nessus_vuln.cve_list[0]  # Use first CVE as primary

            self.db.add(vulnerability)
            return vulnerability

        except Exception as e:
            logger.error(f"Error creating vulnerability from Nessus: {str(e)}")
            return None

    def _map_nessus_severity(self, nessus_severity: int) -> VulnerabilitySeverity:
        """Map Nessus numeric severity to standard severity enum"""
        severity_map = {
            0: VulnerabilitySeverity.INFO,
            1: VulnerabilitySeverity.LOW,
            2: VulnerabilitySeverity.MEDIUM,
            3: VulnerabilitySeverity.HIGH,
            4: VulnerabilitySeverity.CRITICAL
        }
        return severity_map.get(nessus_severity, VulnerabilitySeverity.UNKNOWN)

    def _get_or_create_port(self, host: Host, port_num: int, scan: Scan) -> Port:
        """Get existing port or create new one"""

        existing_port = self.db.query(Port).filter(
            Port.host_id == host.id,
            Port.port_number == port_num,
            Port.protocol == 'tcp'  # Nessus typically uses TCP
        ).first()

        if existing_port:
            existing_port.last_seen = datetime.utcnow()
            existing_port.last_updated_scan_id = scan.id
            return existing_port

        # Create new port
        port = Port(
            host_id=host.id,
            port_number=port_num,
            protocol='tcp',
            state='open',  # Assume open if Nessus found vulns
            last_updated_scan_id=scan.id,
            first_seen=datetime.utcnow(),
            last_seen=datetime.utcnow()
        )

        self.db.add(port)
        self.db.flush()
        return port

    def _find_existing_vulnerability(
        self,
        host: Host,
        port: Optional[Port],
        plugin_id: str,
        source: VulnerabilitySource
    ) -> Optional[Vulnerability]:
        """Find existing vulnerability by plugin_id and context"""

        query = self.db.query(Vulnerability).filter(
            Vulnerability.host_id == host.id,
            Vulnerability.plugin_id == plugin_id,
            Vulnerability.source == source
        )

        if port:
            query = query.filter(Vulnerability.port_id == port.id)
        else:
            query = query.filter(Vulnerability.port_id.is_(None))

        return query.first()

    def _format_references(self, nessus_vuln: NessusVulnerability) -> Optional[str]:
        """Format Nessus references as JSON string"""
        references = []

        if nessus_vuln.cve_list:
            for cve in nessus_vuln.cve_list:
                references.append(f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}")

        # Note: see_also attribute not available in current NessusVulnerability model

        return str(references) if references else None

    def get_host_vulnerability_summary(self, host_id: int) -> Dict[str, Any]:
        """Get vulnerability summary for a host across all sources"""

        vulnerabilities = self.db.query(Vulnerability).filter(
            Vulnerability.host_id == host_id
        ).all()

        summary = {
            "total": len(vulnerabilities),
            "by_severity": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0,
                "unknown": 0
            },
            "by_source": {},
            "vulnerabilities": []
        }

        for vuln in vulnerabilities:
            # Count by severity
            if vuln.severity:
                summary["by_severity"][vuln.severity.value] += 1

            # Count by source
            source = vuln.source.value if vuln.source else "unknown"
            summary["by_source"][source] = summary["by_source"].get(source, 0) + 1

            # Add to list
            summary["vulnerabilities"].append(vuln.to_dict())

        return summary

    def get_dashboard_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics for dashboard"""

        total_vulns = self.db.query(Vulnerability).count()

        # Count by severity
        severity_counts = {}
        for severity in VulnerabilitySeverity:
            count = self.db.query(Vulnerability).filter(
                Vulnerability.severity == severity
            ).count()
            severity_counts[severity.value] = count

        # Count by source
        source_counts = {}
        for source in VulnerabilitySource:
            count = self.db.query(Vulnerability).filter(
                Vulnerability.source == source
            ).count()
            source_counts[source.value] = count

        # Hosts with vulnerabilities
        hosts_with_vulns = self.db.query(Vulnerability.host_id).distinct().count()

        return {
            "total_vulnerabilities": total_vulns,
            "severity_breakdown": severity_counts,
            "source_breakdown": source_counts,
            "hosts_with_vulnerabilities": hosts_with_vulns
        }